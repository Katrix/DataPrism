<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/Katrix/DataPrism" data-githubContributorsFilename="docs/_docs/guide/02_queries.md" data-pathToRoot=""><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Queries</title><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></link><script type="text/javascript" src="scripts/theme.js"></script><script type="text/javascript" src="scripts/searchData.js" defer="true"></script><script type="text/javascript" src="scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="styles/theme/bundle.css"></link><link rel="stylesheet" href="styles/theme/components/bundle.css"></link><link rel="stylesheet" href="styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="styles/nord-light.css"></link><link rel="stylesheet" href="styles/dotty-icons.css"></link><link rel="stylesheet" href="styles/filter-bar.css"></link><link rel="stylesheet" href="styles/code-snippets.css"></link><link rel="stylesheet" href="styles/searchbar.css"></link><link rel="stylesheet" href="styles/social-links.css"></link><link rel="stylesheet" href="styles/versions-dropdown.css"></link><link rel="stylesheet" href="styles/content-contributors.css"></link><link rel="stylesheet" href="styles/fontawesome.css"></link><script type="text/javascript" src="hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="scripts/ux.js" defer="true"></script><script type="text/javascript" src="scripts/common/component.js" defer="true"></script><script type="text/javascript" src="scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="scripts/data.js" defer="true"></script><link rel="stylesheet" href="styles/staticsitestyles.css"></link><script>var pathToRoot = "";</script></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="" class="logo-container"><span class="project-name h300">DataPrism</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">0.0.0+54-3dab9399-SNAPSHOT</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span class="project-name h300">DataPrism</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="index.html">Docs</a><a id="api-nav-button" class="switcher h100 " href="api/index.html">API</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0 "><span class="nh de"><a href="01_table_definitions.html"><span>Table definitions</span></a></span></div><div class="ni n0 expanded"><span class="nh h100 selected de"><a href="#"><span>Queries</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="03_operations.html"><span>Operations (SELECT, INSERT, UPDATE, DELETE)</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="04_types.html"><span>Types</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="05_dbvalue_expressions.html"><span>DbValue and Expressions</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="06_compiled.html"><span>Compiled queries and commands</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="07_mapres_exotic_data.html"><span>MapRes and Exotic data</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="08_transactions.html"><span>Transactions</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="09_cats_effects.html"><span>Usage with Cats effects</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="10_fs2_effects.html"><span>Usage with Fs2</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="11_skunk.html"><span>Usage with Skunk</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/Katrix/DataPrism"><button class="icon-button gh"></button></a><div class="text"></div></div><div class="text-mobile"></div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="index.html">DataPrism</a>/<a href="02_queries.html">Queries</a></div><div id="content" class="body-medium"><div><section id="queries-1"> 
 <h1 class="h500"><a href="#queries-1" class="anchor"></a>Queries</h1> 
 <p>With the user type and table definition in hard, the next step is to construct some queries using this table.</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import dataprism.KMacros
</span><span line-number="2" class=""><span class="tooltip-container"></span>import dataprism.sql.{Table, Column}
</span><span line-number="3" class=""><span class="tooltip-container"></span>import dataprism.jdbc.sql.JdbcCodec
</span><span line-number="4" class=""><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.*
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>case class UserK[F[_]](
</span><span line-number="7" class=""><span class="tooltip-container"></span>  id: F[Int],
</span><span line-number="8" class=""><span class="tooltip-container"></span>  name: F[Option[String]],
</span><span line-number="9" class=""><span class="tooltip-container"></span>  username: F[String],
</span><span line-number="10" class=""><span class="tooltip-container"></span>  email: F[String]
</span><span line-number="11" class=""><span class="tooltip-container"></span>)
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>object UserK:
</span><span line-number="14" class=""><span class="tooltip-container"></span>  // Snippet compiler fails here sadly
</span><span line-number="15" class=""><span class="tooltip-container"></span>  given KMacros.ApplyTraverseKC[UserK] = ??? // KMacros.deriveApplyTraverseKC[UserK]
</span><span line-number="16" class=""><span class="tooltip-container"></span>
</span><span line-number="17" class=""><span class="tooltip-container"></span>  val table: Table[JdbcCodec, UserK] = Table(
</span><span line-number="18" class=""><span class="tooltip-container"></span>    "users",
</span><span line-number="19" class=""><span class="tooltip-container"></span>    UserK(
</span><span line-number="20" class=""><span class="tooltip-container"></span>      Column("id", integer),
</span><span line-number="21" class=""><span class="tooltip-container"></span>      Column("name", text.nullable),
</span><span line-number="22" class=""><span class="tooltip-container"></span>      Column("username", text),
</span><span line-number="23" class=""><span class="tooltip-container"></span>      Column("email", text)
</span><span line-number="24" class=""><span class="tooltip-container"></span>    )
</span><span line-number="25" class=""><span class="tooltip-container"></span>  )
</span></code></pre> 
  <div class="snippet-meta"> 
   <div class="snippet-label">
     User.scala 
   </div> 
  </div> 
  <div class="buttons"></div> 
 </div> 
 <p>For basically anything that manipulates database values, one needs a <code>QueryPlatform</code>. Once again, you should select a platform based on the database and codec type you are using. From here on, unless specified otherwise, these docs will use <code>PostgresJdbcPlatform</code>.</p> 
</section> 
<section id="queryfrom-map-filter-limit-offset-1"> 
 <h2 class="h500"><a href="#queryfrom-map-filter-limit-offset-1" class="anchor"></a>Query.from, map, filter, limit, offset</h2> 
 <p>A query can be constructed using <code>Query.from(table)</code>. From there you can do various things on the query, like map, filter, grouping and more. Here are some simple examples. The types of the values are annotated for better understanding.</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class="hideable include"><span class="tooltip-container"></span>import dataprism.KMacros
</span><span line-number="2" class="hideable include"><span class="tooltip-container"></span>import dataprism.sql.{Table, Column}
</span><span line-number="3" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.JdbcCodec
</span><span line-number="4" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.*
</span><span line-number="5" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="6" class="hideable include"><span class="tooltip-container"></span>case class UserK[F[_]](
</span><span line-number="7" class="hideable include"><span class="tooltip-container"></span>  id: F[Int],
</span><span line-number="8" class="hideable include"><span class="tooltip-container"></span>  name: F[Option[String]],
</span><span line-number="9" class="hideable include"><span class="tooltip-container"></span>  username: F[String],
</span><span line-number="10" class="hideable include"><span class="tooltip-container"></span>  email: F[String]
</span><span line-number="11" class="hideable include"><span class="tooltip-container"></span>)
</span><span line-number="12" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="13" class="hideable include"><span class="tooltip-container"></span>object UserK:
</span><span line-number="14" class="hideable include"><span class="tooltip-container"></span>  // Snippet compiler fails here sadly
</span><span line-number="15" class="hideable include"><span class="tooltip-container"></span>  given KMacros.ApplyTraverseKC[UserK] = ??? // KMacros.deriveApplyTraverseKC[UserK]
</span><span line-number="16" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="17" class="hideable include"><span class="tooltip-container"></span>  val table: Table[JdbcCodec, UserK] = Table(
</span><span line-number="18" class="hideable include"><span class="tooltip-container"></span>    "users",
</span><span line-number="19" class="hideable include"><span class="tooltip-container"></span>    UserK(
</span><span line-number="20" class="hideable include"><span class="tooltip-container"></span>      Column("id", integer),
</span><span line-number="21" class="hideable include"><span class="tooltip-container"></span>      Column("name", text.nullable),
</span><span line-number="22" class="hideable include"><span class="tooltip-container"></span>      Column("username", text),
</span><span line-number="23" class="hideable include"><span class="tooltip-container"></span>      Column("email", text)
</span><span line-number="24" class="hideable include"><span class="tooltip-container"></span>    )
</span><span line-number="25" class="hideable include"><span class="tooltip-container"></span>  )
</span><span line-number="26" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="27" class=""><span class="tooltip-container"></span>import dataprism.jdbc.platform.PostgresJdbcPlatform.Api.*
</span><span line-number="28" class=""><span class="tooltip-container"></span>
</span><span line-number="29" class=""><span class="tooltip-container"></span>val q: Query[UserK] = Query.from(UserK.table)
</span><span line-number="30" class=""><span class="tooltip-container"></span>
</span><span line-number="31" class=""><span class="tooltip-container"></span>val q2: Query[UserK] = q.map((u: UserK[DbValue]) =&gt;
</span><span line-number="32" class=""><span class="tooltip-container"></span>  u.copy(name = u.name.getOrElse(u.username).asSome)
</span><span line-number="33" class=""><span class="tooltip-container"></span>)
</span><span line-number="34" class=""><span class="tooltip-container"></span>
</span><span line-number="35" class=""><span class="tooltip-container"></span>val q3: Query[UserK] = q.filter((u: UserK[DbValue]) =&gt; u.name.isDefined)
</span><span line-number="36" class=""><span class="tooltip-container"></span>
</span><span line-number="37" class=""><span class="tooltip-container"></span>val v1: DbValue[Long] = q.size
</span><span line-number="38" class=""><span class="tooltip-container"></span>
</span><span line-number="39" class=""><span class="tooltip-container"></span>val q4: Query[[F[_]] =&gt;&gt; F[String]] = q.map((u: UserK[DbValue]) =&gt; u.username)
</span><span line-number="40" class=""><span class="tooltip-container"></span>
</span><span line-number="41" class=""><span class="tooltip-container"></span>val q5: Query[[F[_]] =&gt;&gt; (F[String], F[String])] = q.map(
</span><span line-number="42" class=""><span class="tooltip-container"></span>  (u: UserK[DbValue]) =&gt; (u.username, u.email)
</span><span line-number="43" class=""><span class="tooltip-container"></span>)
</span><span line-number="44" class=""><span class="tooltip-container"></span>
</span><span line-number="45" class=""><span class="tooltip-container"></span>val q6: Query[UserK] = q.drop(2).limit(5).offset(3)
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>Within queries, all values above are wrapped in <code>DbValue</code>. This type does however not appear it the <code>Query</code> type. The <code>Query</code> type only knows about the abstract HKD type.</p> 
</section> 
<section id="joins-1"> 
 <h2 class="h500"><a href="#joins-1" class="anchor"></a>Joins</h2> 
 <p>Not all queries operate on plain <code>DbValue</code>s. Joins are one example. While full (normal) joins require both sides to be present, other join types might make one side nullable. This is represented by the <code>Nullable</code> type.</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>type Nullable[A] &lt;: Option[_] = A match {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case Option[b] =&gt; Option[b]
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case _ =&gt; Option[A]
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p><code>Nullable</code> wraps any type in <code>Option</code>, unless it is already wrapped in <code>Option</code>. For example:</p> 
 <ul> 
  <li><code>Nullable[Int]</code> is <code>Option[Int]</code></li> 
  <li><code>Nullable[Option[Int]]</code> is <code>Option[Int]</code></li> 
 </ul> 
 <p>Here is an example how <code>UserK[Nullable]</code> would look as a plain case class (take note of how <code>Nullable</code> keeps the type of <code>name</code> the same).</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// A nullable user. That is to say UserK[Nullable] 
</span><span line-number="2" class=""><span class="tooltip-container"></span>case class NullableUser(
</span><span line-number="3" class=""><span class="tooltip-container"></span>  id: Option[Int],
</span><span line-number="4" class=""><span class="tooltip-container"></span>  name: Option[String],
</span><span line-number="5" class=""><span class="tooltip-container"></span>  username: Option[String],
</span><span line-number="6" class=""><span class="tooltip-container"></span>  email: Option[String]
</span><span line-number="7" class=""><span class="tooltip-container"></span>)
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>With that, here are the <code>Query</code> types for joins.</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class="hideable include"><span class="tooltip-container"></span>import dataprism.KMacros
</span><span line-number="2" class="hideable include"><span class="tooltip-container"></span>import dataprism.sql.{Table, Column}
</span><span line-number="3" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.JdbcCodec
</span><span line-number="4" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.*
</span><span line-number="5" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="6" class="hideable include"><span class="tooltip-container"></span>case class UserK[F[_]](
</span><span line-number="7" class="hideable include"><span class="tooltip-container"></span>  id: F[Int],
</span><span line-number="8" class="hideable include"><span class="tooltip-container"></span>  name: F[Option[String]],
</span><span line-number="9" class="hideable include"><span class="tooltip-container"></span>  username: F[String],
</span><span line-number="10" class="hideable include"><span class="tooltip-container"></span>  email: F[String]
</span><span line-number="11" class="hideable include"><span class="tooltip-container"></span>)
</span><span line-number="12" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="13" class="hideable include"><span class="tooltip-container"></span>object UserK:
</span><span line-number="14" class="hideable include"><span class="tooltip-container"></span>  // Snippet compiler fails here sadly
</span><span line-number="15" class="hideable include"><span class="tooltip-container"></span>  given KMacros.ApplyTraverseKC[UserK] = ??? // KMacros.deriveApplyTraverseKC[UserK]
</span><span line-number="16" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="17" class="hideable include"><span class="tooltip-container"></span>  val table: Table[JdbcCodec, UserK] = Table(
</span><span line-number="18" class="hideable include"><span class="tooltip-container"></span>    "users",
</span><span line-number="19" class="hideable include"><span class="tooltip-container"></span>    UserK(
</span><span line-number="20" class="hideable include"><span class="tooltip-container"></span>      Column("id", integer),
</span><span line-number="21" class="hideable include"><span class="tooltip-container"></span>      Column("name", text.nullable),
</span><span line-number="22" class="hideable include"><span class="tooltip-container"></span>      Column("username", text),
</span><span line-number="23" class="hideable include"><span class="tooltip-container"></span>      Column("email", text)
</span><span line-number="24" class="hideable include"><span class="tooltip-container"></span>    )
</span><span line-number="25" class="hideable include"><span class="tooltip-container"></span>  )
</span><span line-number="26" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="27" class=""><span class="tooltip-container"></span>import dataprism.jdbc.platform.PostgresJdbcPlatform.Api.*
</span><span line-number="28" class=""><span class="tooltip-container"></span>
</span><span line-number="29" class=""><span class="tooltip-container"></span>// Generally you'd just import perspective.Compose2
</span><span line-number="30" class=""><span class="tooltip-container"></span>type Compose2[A[_], B[_]] = [X] =&gt;&gt; A[B[X]]
</span><span line-number="31" class=""><span class="tooltip-container"></span>
</span><span line-number="32" class=""><span class="tooltip-container"></span>val q: Query[UserK] = Query.from(UserK.table)
</span><span line-number="33" class=""><span class="tooltip-container"></span>
</span><span line-number="34" class=""><span class="tooltip-container"></span>val innerJoin: Query[[F[_]] =&gt;&gt; (UserK[F], UserK[F])] = q.join(q)(_.username === _.username)
</span><span line-number="35" class=""><span class="tooltip-container"></span>
</span><span line-number="36" class=""><span class="tooltip-container"></span>val leftJoin: Query[[F[_]] =&gt;&gt; (UserK[F], UserK[Compose2[F, Nullable]])] =
</span><span line-number="37" class=""><span class="tooltip-container"></span>  q.leftJoin(UserK.table)(_.username === _.username)
</span><span line-number="38" class=""><span class="tooltip-container"></span>
</span><span line-number="39" class=""><span class="tooltip-container"></span>val rightJoin: Query[[F[_]] =&gt;&gt; (UserK[Compose2[F, Nullable]], UserK[F])] =
</span><span line-number="40" class=""><span class="tooltip-container"></span>  q.rightJoin(UserK.table)(_.username === _.username)
</span><span line-number="41" class=""><span class="tooltip-container"></span>
</span><span line-number="42" class=""><span class="tooltip-container"></span>val fullJoin: Query[[F[_]] =&gt;&gt; (UserK[Compose2[F, Nullable]], UserK[Compose2[F, Nullable]])] =
</span><span line-number="43" class=""><span class="tooltip-container"></span>  q.fullJoin(UserK.table)(_.username === _.username)
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>As can also be seen in this example, you can join on a query, or directly on a table.</p> 
</section> 
<section id="groupmap-1"> 
 <h2 class="h500"><a href="#groupmap-1" class="anchor"></a>groupMap</h2> 
 <p>The last query function to look at is <code>groupMap</code>. DataPrism does not expose a traditional <code>groupBy</code> function, as a <code>groupMap</code> function maps better to DataPrism's style. <code>groupMap</code> takes two functions as arguments. The first one exctracts the values to group by. The second function does the aggregation given both the extracted value, and the values of the query, which are now wrapped in <code>Many</code>. Here are some examples:</p> 
 <p>Arrays are currently out of commission.</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class="hideable include"><span class="tooltip-container"></span>import dataprism.KMacros
</span><span line-number="2" class="hideable include"><span class="tooltip-container"></span>import dataprism.sql.{Table, Column}
</span><span line-number="3" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.JdbcCodec
</span><span line-number="4" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.*
</span><span line-number="5" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="6" class="hideable include"><span class="tooltip-container"></span>case class UserK[F[_]](
</span><span line-number="7" class="hideable include"><span class="tooltip-container"></span>  id: F[Int],
</span><span line-number="8" class="hideable include"><span class="tooltip-container"></span>  name: F[Option[String]],
</span><span line-number="9" class="hideable include"><span class="tooltip-container"></span>  username: F[String],
</span><span line-number="10" class="hideable include"><span class="tooltip-container"></span>  email: F[String]
</span><span line-number="11" class="hideable include"><span class="tooltip-container"></span>)
</span><span line-number="12" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="13" class="hideable include"><span class="tooltip-container"></span>object UserK:
</span><span line-number="14" class="hideable include"><span class="tooltip-container"></span>  // Snippet compiler fails here sadly
</span><span line-number="15" class="hideable include"><span class="tooltip-container"></span>  given KMacros.ApplyTraverseKC[UserK] = ??? // KMacros.deriveApplyTraverseKC[UserK]
</span><span line-number="16" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="17" class="hideable include"><span class="tooltip-container"></span>  val table: Table[JdbcCodec, UserK] = Table(
</span><span line-number="18" class="hideable include"><span class="tooltip-container"></span>    "users",
</span><span line-number="19" class="hideable include"><span class="tooltip-container"></span>    UserK(
</span><span line-number="20" class="hideable include"><span class="tooltip-container"></span>      Column("id", integer),
</span><span line-number="21" class="hideable include"><span class="tooltip-container"></span>      Column("name", text.nullable),
</span><span line-number="22" class="hideable include"><span class="tooltip-container"></span>      Column("username", text),
</span><span line-number="23" class="hideable include"><span class="tooltip-container"></span>      Column("email", text)
</span><span line-number="24" class="hideable include"><span class="tooltip-container"></span>    )
</span><span line-number="25" class="hideable include"><span class="tooltip-container"></span>  )
</span><span line-number="26" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="27" class=""><span class="tooltip-container"></span>/*
</span><span line-number="28" class=""><span class="tooltip-container"></span>import dataprism.jdbc.platform.PostgresJdbcPlatform.Api.*
</span><span line-number="29" class=""><span class="tooltip-container"></span>
</span><span line-number="30" class=""><span class="tooltip-container"></span>//Needed for arrayAgg currently
</span><span line-number="31" class=""><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.ArrayMapping.given_ArrayMapping_A
</span><span line-number="32" class=""><span class="tooltip-container"></span>
</span><span line-number="33" class=""><span class="tooltip-container"></span>val q: Query[UserK] = Query.from(UserK.table)
</span><span line-number="34" class=""><span class="tooltip-container"></span>
</span><span line-number="35" class=""><span class="tooltip-container"></span>val q1: Query[[F[_]] =&gt;&gt; (F[String], F[Seq[String]])] =
</span><span line-number="36" class=""><span class="tooltip-container"></span>  q.groupMap((v: UserK[DbValue]) =&gt; v.email)(
</span><span line-number="37" class=""><span class="tooltip-container"></span>    (email: DbValue[String], v: UserK[Many]) =&gt; (email, v.username.arrayAgg)
</span><span line-number="38" class=""><span class="tooltip-container"></span>  )
</span><span line-number="39" class=""><span class="tooltip-container"></span>
</span><span line-number="40" class=""><span class="tooltip-container"></span>val q2: Query[[F[_]] =&gt;&gt; (F[Option[String]], F[String], F[Seq[String]])] =
</span><span line-number="41" class=""><span class="tooltip-container"></span>  q.groupMap((v: UserK[DbValue]) =&gt; (v.name, v.username))(
</span><span line-number="42" class=""><span class="tooltip-container"></span>    (t: (DbValue[Option[String]], DbValue[String]), v: UserK[Many]) =&gt;
</span><span line-number="43" class=""><span class="tooltip-container"></span>      (t._1, t._2, v.email.arrayAgg)
</span><span line-number="44" class=""><span class="tooltip-container"></span>  )
</span><span line-number="45" class=""><span class="tooltip-container"></span>*/
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>Note how you don't have to directly return a column from the grouping function. For example, in <code>q3</code> a tuple is used. Anything that works for <code>map</code> also works here.</p> 
</section> 
<section id="flatmaplateral-1"> 
 <h2 class="h500"><a href="#flatmaplateral-1" class="anchor"></a>flatMap/LATERAL</h2> 
 <p>So far the docs have looked at direct function application on the queries, resulting in an applicative style. For databases that support <code>LATERAL</code>, <code>Query</code> also defines <code>flatMap</code>, and because of that for comprehensions. The reason why <code>LATERAL</code> is required is because <code>flatMap</code> is a very powerful function, and producing invalid SQL without <code>LATERAL</code> can be quite easy. If you still want flatMap for a database which does not support <code>LATERAL</code>, create your own platform, and mix in <code>UnsafeSqlQueryPlatformFlatmap</code> into it.</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class="hideable include"><span class="tooltip-container"></span>import dataprism.KMacros
</span><span line-number="2" class="hideable include"><span class="tooltip-container"></span>import dataprism.sql.{Table, Column}
</span><span line-number="3" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.JdbcCodec
</span><span line-number="4" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.*
</span><span line-number="5" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="6" class="hideable include"><span class="tooltip-container"></span>case class UserK[F[_]](
</span><span line-number="7" class="hideable include"><span class="tooltip-container"></span>  id: F[Int],
</span><span line-number="8" class="hideable include"><span class="tooltip-container"></span>  name: F[Option[String]],
</span><span line-number="9" class="hideable include"><span class="tooltip-container"></span>  username: F[String],
</span><span line-number="10" class="hideable include"><span class="tooltip-container"></span>  email: F[String]
</span><span line-number="11" class="hideable include"><span class="tooltip-container"></span>)
</span><span line-number="12" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="13" class="hideable include"><span class="tooltip-container"></span>object UserK:
</span><span line-number="14" class="hideable include"><span class="tooltip-container"></span>  // Snippet compiler fails here sadly
</span><span line-number="15" class="hideable include"><span class="tooltip-container"></span>  given KMacros.ApplyTraverseKC[UserK] = ??? // KMacros.deriveApplyTraverseKC[UserK]
</span><span line-number="16" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="17" class="hideable include"><span class="tooltip-container"></span>  val table: Table[JdbcCodec, UserK] = Table(
</span><span line-number="18" class="hideable include"><span class="tooltip-container"></span>    "users",
</span><span line-number="19" class="hideable include"><span class="tooltip-container"></span>    UserK(
</span><span line-number="20" class="hideable include"><span class="tooltip-container"></span>      Column("id", integer),
</span><span line-number="21" class="hideable include"><span class="tooltip-container"></span>      Column("name", text.nullable),
</span><span line-number="22" class="hideable include"><span class="tooltip-container"></span>      Column("username", text),
</span><span line-number="23" class="hideable include"><span class="tooltip-container"></span>      Column("email", text)
</span><span line-number="24" class="hideable include"><span class="tooltip-container"></span>    )
</span><span line-number="25" class="hideable include"><span class="tooltip-container"></span>  )
</span><span line-number="26" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="27" class=""><span class="tooltip-container"></span>import dataprism.jdbc.platform.PostgresJdbcPlatform.Api.*
</span><span line-number="28" class=""><span class="tooltip-container"></span>
</span><span line-number="29" class=""><span class="tooltip-container"></span>//TODO: Does not compile for some reason. Fix MapRes
</span><span line-number="30" class=""><span class="tooltip-container"></span>//val q1: Query[[F[_]] =&gt;&gt; (UserK[F], UserK[F])] =
</span><span line-number="31" class=""><span class="tooltip-container"></span>//  Query.from(UserK.table).flatMap(u1 =&gt; Query.from(UserK.table).map(u2 =&gt; (u1, u2)))
</span><span line-number="32" class=""><span class="tooltip-container"></span>
</span><span line-number="33" class=""><span class="tooltip-container"></span>val q2: Query[UserK] = for
</span><span line-number="34" class=""><span class="tooltip-container"></span>  u &lt;- Query.from(UserK.table)
</span><span line-number="35" class=""><span class="tooltip-container"></span>  u2 &lt;- Query.from(UserK.table)
</span><span line-number="36" class=""><span class="tooltip-container"></span>  if u.email === u2.email
</span><span line-number="37" class=""><span class="tooltip-container"></span>yield u2
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
</section> 
<section id="mapping-to-other-higher-kinded-data-1"> 
 <h2 class="h500"><a href="#mapping-to-other-higher-kinded-data-1" class="anchor"></a>Mapping to other Higher Kinded Data</h2> 
 <p>These examples have generally shown either <code>UserK</code> or a tuple in functions like <code>map</code>, <code>groupMap</code> and similar. The HKD used to define a table is not special. Any HKD (or not even HKD) with <code>perspective.ApplyKC</code> and <code>perspective.TraverseKC</code> instances can be used as a result type in functions like <code>map</code>. Here's one example:</p> 
 <p>Arrays are currently out of commission.</p> 
 <div class="snippet mono-small-block" scala-snippet="" runnable=""> 
  <pre><code class="language-scala"><span line-number="1" class="hideable include"><span class="tooltip-container"></span>import dataprism.KMacros
</span><span line-number="2" class="hideable include"><span class="tooltip-container"></span>import dataprism.sql.{Table, Column}
</span><span line-number="3" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.JdbcCodec
</span><span line-number="4" class="hideable include"><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.*
</span><span line-number="5" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="6" class="hideable include"><span class="tooltip-container"></span>case class UserK[F[_]](
</span><span line-number="7" class="hideable include"><span class="tooltip-container"></span>  id: F[Int],
</span><span line-number="8" class="hideable include"><span class="tooltip-container"></span>  name: F[Option[String]],
</span><span line-number="9" class="hideable include"><span class="tooltip-container"></span>  username: F[String],
</span><span line-number="10" class="hideable include"><span class="tooltip-container"></span>  email: F[String]
</span><span line-number="11" class="hideable include"><span class="tooltip-container"></span>)
</span><span line-number="12" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="13" class="hideable include"><span class="tooltip-container"></span>object UserK:
</span><span line-number="14" class="hideable include"><span class="tooltip-container"></span>  // Snippet compiler fails here sadly
</span><span line-number="15" class="hideable include"><span class="tooltip-container"></span>  given KMacros.ApplyTraverseKC[UserK] = ??? // KMacros.deriveApplyTraverseKC[UserK]
</span><span line-number="16" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="17" class="hideable include"><span class="tooltip-container"></span>  val table: Table[JdbcCodec, UserK] = Table(
</span><span line-number="18" class="hideable include"><span class="tooltip-container"></span>    "users",
</span><span line-number="19" class="hideable include"><span class="tooltip-container"></span>    UserK(
</span><span line-number="20" class="hideable include"><span class="tooltip-container"></span>      Column("id", integer),
</span><span line-number="21" class="hideable include"><span class="tooltip-container"></span>      Column("name", text.nullable),
</span><span line-number="22" class="hideable include"><span class="tooltip-container"></span>      Column("username", text),
</span><span line-number="23" class="hideable include"><span class="tooltip-container"></span>      Column("email", text)
</span><span line-number="24" class="hideable include"><span class="tooltip-container"></span>    )
</span><span line-number="25" class="hideable include"><span class="tooltip-container"></span>  )
</span><span line-number="26" class="hideable include"><span class="tooltip-container"></span>
</span><span line-number="27" class=""><span class="tooltip-container"></span>/*
</span><span line-number="28" class=""><span class="tooltip-container"></span>import dataprism.jdbc.platform.PostgresJdbcPlatform.Api.*
</span><span line-number="29" class=""><span class="tooltip-container"></span>
</span><span line-number="30" class=""><span class="tooltip-container"></span>//Needed for arrayAgg currently
</span><span line-number="31" class=""><span class="tooltip-container"></span>import dataprism.jdbc.sql.PostgresJdbcTypes.ArrayMapping.given_ArrayMapping_A
</span><span line-number="32" class=""><span class="tooltip-container"></span>
</span><span line-number="33" class=""><span class="tooltip-container"></span>case class UsersWithEmailK[F[_]](email: F[String], usernames: F[Seq[String]])
</span><span line-number="34" class=""><span class="tooltip-container"></span>
</span><span line-number="35" class=""><span class="tooltip-container"></span>object UsersWithEmailK:
</span><span line-number="36" class=""><span class="tooltip-container"></span>  // Snippet compiler fails here sadly
</span><span line-number="37" class=""><span class="tooltip-container"></span>  given KMacros.ApplyTraverseKC[UsersWithEmailK] = ??? // KMacros.deriveApplyTraverseKC[UsersWithEmailK]
</span><span line-number="38" class=""><span class="tooltip-container"></span>
</span><span line-number="39" class=""><span class="tooltip-container"></span>val q1: Query[UsersWithEmailK] =
</span><span line-number="40" class=""><span class="tooltip-container"></span>  Query.from(UserK.table).groupMap((v: UserK[DbValue]) =&gt; v.email)(
</span><span line-number="41" class=""><span class="tooltip-container"></span>    (email: DbValue[String], v: UserK[Many]) =&gt; UsersWithEmailK(email, v.username.arrayAgg)
</span><span line-number="42" class=""><span class="tooltip-container"></span>  )
</span><span line-number="43" class=""><span class="tooltip-container"></span>*/
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>For more info, see <a href="07_mapres_exotic_data.html">MapRes and Exotic data</a></p> 
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#queries-1">Queries</a><ul><li><a href="#queryfrom-map-filter-limit-offset-1">Query.from, map, filter, limit, offset</a></li><li><a href="#joins-1">Joins</a></li><li><a href="#groupmap-1">groupMap</a></li><li><a href="#flatmaplateral-1">flatMap/LATERAL</a></li><li><a href="#mapping-to-other-higher-kinded-data-1">Mapping to other Higher Kinded Data</a></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://gitter.im/scala/scala"><button class="icon-button gitter"></button></a><div class="text"></div></div><div class="text-mobile"></div></div></div></div></body></html>